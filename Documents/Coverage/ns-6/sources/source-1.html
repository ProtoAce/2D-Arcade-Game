


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > EnemyLogic</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.Logic</a>
</div>

<h1>Coverage Summary for Class: EnemyLogic (com.Logic)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EnemyLogic</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.8%
  </span>
  <span class="absValue">
    (83/111)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87%
  </span>
  <span class="absValue">
    (120/138)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EnemyLogic$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.8%
  </span>
  <span class="absValue">
    (83/111)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.1%
  </span>
  <span class="absValue">
    (121/139)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.Logic;
&nbsp;
&nbsp;import com.Board.BoardData;
&nbsp;import com.Entities.Enemy;
&nbsp;import com.Entities.Position;
&nbsp;import com.Game.GameStats;
&nbsp;import com.Game.ObjectData;
&nbsp;import com.Helpers.Direction;
&nbsp;import com.Helpers.Node;
&nbsp;import com.Board.Objects;
&nbsp;
&nbsp;import java.util.*;
&nbsp;
&nbsp;
&nbsp;/**
&nbsp; * Handles all logic regarding enemy movement
&nbsp; */
<b class="fc">&nbsp;public class EnemyLogic {</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Handles the movement of all enemies using a &quot;shortest path algorithm&quot; towards the hero
&nbsp;     * Once a movement direction is found, checks for enemy collision and hidden hero are done
&nbsp;     * When moving the board tile data is updated for the enemy tile prior and post movement.
&nbsp;     * @param gameObjectData Contains all game data. BoardData, GameStats, enemies list are used/updated
&nbsp;     */
&nbsp;    public void processEnemyMovement(ObjectData gameObjectData) {
&nbsp;
<b class="fc">&nbsp;        BoardData board = gameObjectData.getBoard();</b>
<b class="fc">&nbsp;        GameStats gameStats = gameObjectData.getGameStats();</b>
<b class="fc">&nbsp;        ArrayList&lt;Enemy&gt; enemies = gameObjectData.getEnemies();</b>
&nbsp;
<b class="fc">&nbsp;        Objects[][] boardArr = board.getBoardData();</b>
&nbsp;
<b class="fc">&nbsp;        int width = boardArr.length;</b>
<b class="fc">&nbsp;        int height = boardArr[0].length;</b>
&nbsp;
<b class="fc">&nbsp;        boolean correctLoop = false;</b>
<b class="fc">&nbsp;        boolean swapthree = false;</b>
<b class="fc">&nbsp;        boolean swaplasttwo = false;</b>
&nbsp;
<b class="fc">&nbsp;        while(correctLoop == false) {</b>
<b class="fc">&nbsp;            correctLoop = true;</b>
&nbsp;
&nbsp;            //process movement for each enemy on board
<b class="fc">&nbsp;            for (Enemy enemy : enemies) {</b>
&nbsp;
<b class="fc">&nbsp;                Objects[][] tempArr = new Objects[width][height];</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; width; i++) {</b>
<b class="fc">&nbsp;                    System.arraycopy(boardArr[i], 0, tempArr[i], 0, height);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                Direction nextMove = findShortestPath(tempArr, enemy);</b>
&nbsp;
&nbsp;                //get  random direction and make sure it&#39;s not going into a tree or exit
<b class="fc">&nbsp;                if (nextMove == Direction.RANDOM) {</b>
<b class="fc">&nbsp;                    nextMove = getRandomDirection(board, enemy);</b>
&nbsp;                }
&nbsp;
&nbsp;                //check for two enemies colliding, if so, don&#39;t move
<b class="fc">&nbsp;                Objects nextTile = Objects.TMP;</b>
<b class="pc">&nbsp;                switch (nextMove) {</b>
<b class="fc">&nbsp;                    case NORTH -&gt; nextTile = board.getTypeAt(enemy.getX(), enemy.getY() - 1);</b>
<b class="fc">&nbsp;                    case EAST -&gt; nextTile = board.getTypeAt(enemy.getX() + 1, enemy.getY());</b>
<b class="fc">&nbsp;                    case SOUTH -&gt; nextTile = board.getTypeAt(enemy.getX(), enemy.getY() + 1);</b>
<b class="fc">&nbsp;                    case WEST -&gt; nextTile = board.getTypeAt(enemy.getX() - 1, enemy.getY());</b>
&nbsp;                }
&nbsp;                //2 or more enemies
<b class="fc">&nbsp;                if (nextTile == Objects.ENEMY) {</b>
&nbsp;                    //nextMove = Direction.NULL;
&nbsp;                    //Testing code
&nbsp;                    //medium
<b class="pc">&nbsp;                    if (enemies.size() == 2) {</b>
<b class="pc">&nbsp;                        if ( enemies.indexOf(enemy) == 0 ) {</b>
&nbsp;                            //If there is enemy in the front, switch enemy order and try again
<b class="fc">&nbsp;                            Collections.swap(enemies, 0, 1);</b>
<b class="fc">&nbsp;                            correctLoop = false;</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            nextMove = Direction.NULL;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if(enemies.size() == 3){</b>
<b class="nc">&nbsp;                        if (enemies.indexOf(enemy) == 0) {</b>
&nbsp;                            //If there is enemy in the front, rotate to back of enemy order and try again
<b class="nc">&nbsp;                            Collections.swap(enemies, 0, 2);</b>
<b class="nc">&nbsp;                            Collections.swap(enemies, 0, 1);</b>
<b class="nc">&nbsp;                            correctLoop = false;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if ( (enemies.indexOf(enemy) == 1) &amp;&amp; !swaplasttwo) {</b>
&nbsp;                            //If there is enemy in the front, rotate 2nd and 3rd enemy
<b class="nc">&nbsp;                            Collections.swap(enemies, 1, 2);</b>
<b class="nc">&nbsp;                            correctLoop = false;</b>
<b class="nc">&nbsp;                            swapthree = true;</b>
<b class="nc">&nbsp;                            swaplasttwo = true;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                        else {
<b class="nc">&nbsp;                            nextMove = Direction.NULL;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //First enemy moved and now has to not move
<b class="pc">&nbsp;                if (swapthree &amp;&amp; enemies.indexOf(enemy) == 0){</b>
<b class="nc">&nbsp;                    nextMove = Direction.NULL;</b>
&nbsp;                }
&nbsp;
&nbsp;                //if Moving, update board tiles accordingly
<b class="pc">&nbsp;                if (nextMove != Direction.NULL) {</b>
<b class="fc">&nbsp;                    Objects currentTile = board.getTypeAt(enemy);</b>
<b class="fc">&nbsp;                    if (currentTile == Objects.ENEMYANDREWARD) {</b>
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.REWARD);</b>
<b class="fc">&nbsp;                    } else if (currentTile == Objects.ENEMYANDTRAP) {</b>
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.TRAP);</b>
<b class="fc">&nbsp;                    } else if (currentTile == Objects.ENEMYANDBUSH) {</b>
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.BUSH);</b>
<b class="fc">&nbsp;                    } else if (currentTile == Objects.ENEMYANDBONUS) {</b>
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.BONUS);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.EMPTY);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //Adjust enemies location and the direction it is facing
<b class="pc">&nbsp;                switch (nextMove) {</b>
&nbsp;                    case NORTH:
<b class="fc">&nbsp;                        enemy.decrementY();</b>
<b class="fc">&nbsp;                        enemy.setDir(Direction.NORTH);</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case EAST:
<b class="fc">&nbsp;                        enemy.incrementX();</b>
<b class="fc">&nbsp;                        enemy.setDir(Direction.EAST);</b>
&nbsp;
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case SOUTH:
<b class="fc">&nbsp;                        enemy.incrementY();</b>
<b class="fc">&nbsp;                        enemy.setDir(Direction.SOUTH);</b>
&nbsp;
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case WEST:
<b class="fc">&nbsp;                        enemy.decrementX();</b>
<b class="fc">&nbsp;                        enemy.setDir(Direction.WEST);</b>
&nbsp;
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case NULL:
&nbsp;                        break;
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                //if enemy moved, update new tiles information
<b class="pc">&nbsp;                if (nextMove != Direction.NULL) {</b>
<b class="fc">&nbsp;                    Objects currentTile = board.getTypeAt(enemy);</b>
<b class="fc">&nbsp;                    if (currentTile == Objects.REWARD) {</b>
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.ENEMYANDREWARD);</b>
<b class="fc">&nbsp;                    } else if (currentTile == Objects.TRAP) {</b>
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.ENEMYANDTRAP);</b>
<b class="fc">&nbsp;                    } else if (currentTile == Objects.BUSH) {</b>
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.ENEMYANDBUSH);</b>
<b class="fc">&nbsp;                    } else if (currentTile == Objects.BONUS) {</b>
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.ENEMYANDBONUS);</b>
<b class="pc">&nbsp;                    } else if (currentTile == Objects.HERO || currentTile == Objects.HEROHIDDEN) {</b>
<b class="fc">&nbsp;                        gameStats.setGameOver(true);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        board.setTypeAt(enemy, Objects.ENEMY);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a random direction for enemy to move to,
&nbsp;     * that is not towards a tree, exit or enemy tile
&nbsp;     * @param board com.Board data containing all Objects positions
&nbsp;     * @param enemy Enemy that is moving
&nbsp;     * @return A valid Direction for enemy to move to
&nbsp;     */
&nbsp;    private Direction getRandomDirection(BoardData board, Enemy enemy){
<b class="fc">&nbsp;        Random rand = new Random();</b>
<b class="fc">&nbsp;        boolean validDirection = false;</b>
<b class="fc">&nbsp;        Direction nextMove = Direction.NULL;</b>
<b class="fc">&nbsp;        while(!validDirection){</b>
<b class="fc">&nbsp;            int dir = rand.nextInt(4);</b>
<b class="fc">&nbsp;            nextMove = Direction.values()[dir];</b>
<b class="fc">&nbsp;            Objects nextTile = Objects.TREE;</b>
<b class="pc">&nbsp;            switch(nextMove){</b>
<b class="fc">&nbsp;                case NORTH -&gt; nextTile = board.getTypeAt(enemy.getX(), enemy.getY() -1);</b>
<b class="fc">&nbsp;                case EAST -&gt;  nextTile = board.getTypeAt(enemy.getX() + 1, enemy.getY());</b>
<b class="nc">&nbsp;                case SOUTH -&gt; nextTile = board.getTypeAt(enemy.getX(), enemy.getY() +1);</b>
<b class="nc">&nbsp;                case WEST -&gt;  nextTile = board.getTypeAt(enemy.getX() - 1, enemy.getY());</b>
&nbsp;            }
&nbsp;
<b class="pc">&nbsp;            if(nextTile!= Objects.TREE &amp;&amp; nextTile != Objects.EXIT &amp;&amp; nextTile != Objects.ENEMY){</b>
<b class="fc">&nbsp;                validDirection = true;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return nextMove;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A Breadth first search is performed on a 2d array starting at the enemy position
&nbsp;     * to find the shortest path to the hero and which direction the first step is.
&nbsp;     * the shortest path may not contain any tree object tiles.
&nbsp;     * If the hero is hidden, and the shortest path is more than 3, the enemy cant &quot;find&quot;
&nbsp;     * the hero and will walk in a random direction
&nbsp;     *
&nbsp;     * @param board com.Board data containing all Objects positions
&nbsp;     * @param enemyPos Enemy that the search is start at
&nbsp;     * @return Direction that the enemy should move (random for hidden case)
&nbsp;     */
&nbsp;    public Direction findShortestPath(Objects[][] board, Position enemyPos) {
<b class="fc">&nbsp;        int width = board.length;</b>
<b class="fc">&nbsp;        int height = board[0].length;</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;        Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;        Node start = new Node(enemyPos, Direction.NULL, 0);</b>
<b class="fc">&nbsp;        q.add(start);</b>
&nbsp;
<b class="pc">&nbsp;        while (!q.isEmpty()) {</b>
<b class="fc">&nbsp;            Node head = q.poll();</b>
&nbsp;
<b class="fc">&nbsp;            if (board[head.getX()][head.getY()] == Objects.HERO) {</b>
<b class="fc">&nbsp;                return head.initialDirection;</b>
<b class="fc">&nbsp;            } else if (board[head.getX()][head.getY()] == Objects.HEROHIDDEN){</b>
<b class="fc">&nbsp;                if (head.pathLength &gt; 3){</b>
&nbsp;                    //squirrel is hidden so enemy moves randomly
<b class="fc">&nbsp;                    return Direction.RANDOM;</b>
&nbsp;                }else{
<b class="fc">&nbsp;                    return head.initialDirection;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            else {
&nbsp;                //Objects.TREE represents tree on the board, I swap a visited node to a tree
&nbsp;                //so that the bfs knows not to search the head node again.
<b class="fc">&nbsp;                board[head.getX()][head.getY()] = Objects.TREE;</b>
&nbsp;
<b class="fc">&nbsp;                q.addAll(getNeighbours(head, board, width, height));</b>
&nbsp;            }
&nbsp;
&nbsp;
<b class="fc">&nbsp;        }</b>
<b class="nc">&nbsp;        return Direction.NULL;</b>
&nbsp;    }
&nbsp;
&nbsp;    //getNeighbours returns a list containing all the direct neighbours to head
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the neighbour nodes of the head node, helper function for {@link #findShortestPath(Objects[][], Position) FindShortestPath}
&nbsp;     * @param head node to get neighbours for
&nbsp;     * @param board board data for all objects
&nbsp;     * @param width max width to search in
&nbsp;     * @param height max height to search in
&nbsp;     * @return List of nodes that are neighbouring the head node
&nbsp;     */
&nbsp;    private List&lt;Node&gt; getNeighbours(Node head, Objects[][] board, int width, int height) {
<b class="fc">&nbsp;        int x = head.getX();</b>
<b class="fc">&nbsp;        int y = head.getY();</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Node&gt; neighbours = new LinkedList&lt;&gt;();</b>
&nbsp;        //check if there is a non tree tile in each direction (North, East, South, West), if so, add it to neighbours list
&nbsp;        //only change the initialDirection if it is the initial node from where the search started (the enemy)
<b class="pc">&nbsp;        if (x + 1 &gt;= 0 &amp;&amp; x + 1 &lt; width &amp;&amp; board[x + 1][y] != Objects.TREE) {</b>
<b class="fc">&nbsp;            if (head.initialDirection == Direction.NULL) {</b>
<b class="fc">&nbsp;                neighbours.add(new Node(new Position(x + 1, y), Direction.EAST, head.pathLength + 1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;                neighbours.add(new Node(new Position(x + 1, y), head.initialDirection, head.pathLength + 1));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if (x - 1 &gt;= 0 &amp;&amp; x - 1 &lt; width &amp;&amp; board[x - 1][y] != Objects.TREE) {</b>
<b class="fc">&nbsp;            if (head.initialDirection == Direction.NULL) {</b>
<b class="fc">&nbsp;                neighbours.add(new Node(new Position(x - 1, y), Direction.WEST, head.pathLength + 1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;                neighbours.add(new Node(new Position(x - 1, y), head.initialDirection, head.pathLength + 1));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if (y + 1 &gt;= 0 &amp;&amp; y + 1 &lt; height &amp;&amp; board[x][y + 1] != Objects.TREE) {</b>
<b class="fc">&nbsp;            if (head.initialDirection == Direction.NULL) {</b>
<b class="fc">&nbsp;                neighbours.add(new Node(new Position(x, y + 1), Direction.SOUTH, head.pathLength + 1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;                neighbours.add(new Node(new Position(x, y + 1), head.initialDirection, head.pathLength + 1));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if (y - 1 &gt;= 0 &amp;&amp; y - 1 &lt; height &amp;&amp; board[x][y - 1] != Objects.TREE) {</b>
<b class="fc">&nbsp;            if (head.initialDirection == Direction.NULL) {</b>
<b class="fc">&nbsp;                neighbours.add(new Node(new Position(x, y - 1), Direction.NORTH, head.pathLength + 1));</b>
&nbsp;            } else {
<b class="fc">&nbsp;                neighbours.add(new Node(new Position(x, y - 1), head.initialDirection, head.pathLength + 1));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return neighbours;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-11-26 23:48</div>
</div>
</body>
</html>
