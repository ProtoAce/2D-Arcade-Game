


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > BoardData</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.Board</a>
</div>

<h1>Coverage Summary for Class: BoardData (com.Board)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BoardData</td>
<td class="coverageStat">
  <span class="percent">
    96.6%
  </span>
  <span class="absValue">
    (28/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.9%
  </span>
  <span class="absValue">
    (140/143)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98%
  </span>
  <span class="absValue">
    (241/246)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BoardData$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    96.7%
  </span>
  <span class="absValue">
    (29/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.9%
  </span>
  <span class="absValue">
    (140/143)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98%
  </span>
  <span class="absValue">
    (242/247)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.Board;
&nbsp;
&nbsp;import com.Entities.Position;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Random;
&nbsp;
<b class="fc">&nbsp;public class BoardData {</b>
&nbsp;
&nbsp;    //if ever need to change map size, this is the location
<b class="fc">&nbsp;    private static int columns = 25;</b>
<b class="fc">&nbsp;    private static int rows = 15;</b>
&nbsp;
&nbsp;    //2Darray of objects containing all of the information to be processed from
&nbsp;    //during the game runtime
<b class="fc">&nbsp;    private static Objects[][] ObjectMap = new Objects[columns][rows];</b>
&nbsp;
&nbsp;
&nbsp;//    private Difficulty dif = Difficulty.HARD;
&nbsp;
&nbsp;    /**
&nbsp;     * Used for replacing a TMP object wall segments with real TREE objects
&nbsp;     * for succesful segment generations
&nbsp;     */
&nbsp;    private void replaceTMPTrees() {
<b class="fc">&nbsp;        for (int i = 0; i &lt; columns; i++) {</b>
<b class="fc">&nbsp;            for (int j = 0; j &lt; rows; j++) {</b>
<b class="fc">&nbsp;                if (ObjectMap[i][j] == Objects.TMP) {</b>
<b class="fc">&nbsp;                    ObjectMap[i][j] = Objects.TREE;</b>
&nbsp;                }
&nbsp;                ;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * helper function for removing TMP tree objects
&nbsp;     * during for innerWall generation
&nbsp;     */
&nbsp;    private void removeTMPTrees() {
<b class="fc">&nbsp;        for (int i = 0; i &lt; columns; i++) {</b>
<b class="fc">&nbsp;            for (int j = 0; j &lt; rows; j++) {</b>
<b class="fc">&nbsp;                if (ObjectMap[i][j] == Objects.TMP) {</b>
<b class="fc">&nbsp;                    ObjectMap[i][j] = Objects.EMPTY;</b>
&nbsp;                }
&nbsp;                ;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * set the perimiter of the map to TREE objects
&nbsp;     */
&nbsp;    public void setOuterWalls() {
<b class="fc">&nbsp;        for (int i = 0; i &lt; rows; i++) {</b>
<b class="fc">&nbsp;            ObjectMap[0][i] = Objects.TREE;</b>
&nbsp;        }
<b class="fc">&nbsp;        for (int i = 0; i &lt; rows; i++) {</b>
<b class="fc">&nbsp;            ObjectMap[columns - 1][i] = Objects.TREE;</b>
&nbsp;        }
<b class="fc">&nbsp;        for (int i = 0; i &lt; columns; i++) {</b>
<b class="fc">&nbsp;            ObjectMap[i][0] = Objects.TREE;</b>
&nbsp;        }
<b class="fc">&nbsp;        for (int i = 0; i &lt; columns; i++) {</b>
<b class="fc">&nbsp;            ObjectMap[i][rows - 1] = Objects.TREE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * used for initilazing board to all EMPTY object tiles
&nbsp;     */
&nbsp;    static void setEmptyTiles() {
<b class="fc">&nbsp;        for (int i = 0; i &lt; columns; i++) {</b>
<b class="fc">&nbsp;            for (int j = 0; j &lt; rows; j++) {</b>
<b class="fc">&nbsp;                ObjectMap[i][j] = Objects.EMPTY;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //helper function
&nbsp;
&nbsp;    /**
&nbsp;     * helper function for checking if any adjencent tiles to given coordinate contains a TREE
&nbsp;     *
&nbsp;     * @param xcoord
&nbsp;     * @param ycoord
&nbsp;     * @return boolean
&nbsp;     *
&nbsp;     */
&nbsp;    static boolean foundAdjacentTrees(int xcoord, int ycoord) {
<b class="fc">&nbsp;        boolean isadjecent = false;</b>
&nbsp;        //check north west east west
<b class="fc">&nbsp;        if (ObjectMap[xcoord + 1][ycoord] == Objects.TREE) {</b>
<b class="fc">&nbsp;            isadjecent = true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (ObjectMap[xcoord][ycoord + 1] == Objects.TREE) {</b>
<b class="fc">&nbsp;            isadjecent = true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (ObjectMap[xcoord - 1][ycoord] == Objects.TREE) {</b>
<b class="fc">&nbsp;            isadjecent = true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (ObjectMap[xcoord + 1][ycoord - 1] == Objects.TREE) {</b>
<b class="fc">&nbsp;            isadjecent = true;</b>
&nbsp;        }
&nbsp;        //check diagonals because those can cause closed off sections
<b class="fc">&nbsp;        if (ObjectMap[xcoord + 1][ycoord + 1] == Objects.TREE) {</b>
<b class="fc">&nbsp;            isadjecent = true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (ObjectMap[xcoord - 1][ycoord + 1] == Objects.TREE) {</b>
<b class="fc">&nbsp;            isadjecent = true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (ObjectMap[xcoord - 1][ycoord - 1] == Objects.TREE) {</b>
<b class="fc">&nbsp;            isadjecent = true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (ObjectMap[xcoord + 1][ycoord - 1] == Objects.TREE) {</b>
<b class="fc">&nbsp;            isadjecent = true;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return isadjecent;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param difficulty calls {@link #setSegment()} 15 times regardless of the difficulty
&nbsp;     *                   to create 15 individual wall segments
&nbsp;     */
&nbsp;    private void setInnerWalls(Difficulty difficulty){
<b class="fc">&nbsp;        int wallsegments = 0;</b>
<b class="pc">&nbsp;        switch(difficulty){</b>
<b class="fc">&nbsp;            case EASY: wallsegments = 15;</b>
<b class="fc">&nbsp;                break;</b>
<b class="fc">&nbsp;            case MEDIUM: wallsegments = 15;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case HARD:
<b class="fc">&nbsp;            case INFINITE: wallsegments = 15;</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (int i = 1; i &lt; wallsegments; i++) {</b>
<b class="fc">&nbsp;            setSegment();</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper function for generating WallSegments
&nbsp;     *generate shapes of either 1,2, or 3 lines with changing directions
&nbsp;     *going north/south -&gt; west/east -&gt; north/south all of varying lenghts
&nbsp;     */
&nbsp;    private void setSegment() {
&nbsp;
<b class="fc">&nbsp;        Random rand = new Random(); //instance of random class</b>
&nbsp;
&nbsp;        //leave a gap between outter walls
<b class="fc">&nbsp;        int maxwallheight = rows - 2;</b>
<b class="fc">&nbsp;        int minwallheight = 2;</b>
&nbsp;
<b class="fc">&nbsp;        int maxwallwidth = columns - 2;</b>
<b class="fc">&nbsp;        int minwallwidth = 2;</b>
&nbsp;
&nbsp;
&nbsp;        //variable holder used for if a wallsegment fails to generate
&nbsp;        //a certain number of times
<b class="fc">&nbsp;        int attempts = 0;</b>
&nbsp;        //keep looping if wall segment is created or not
<b class="fc">&nbsp;        boolean createdwall = false;</b>
<b class="fc">&nbsp;        while (!createdwall) {</b>
&nbsp;
&nbsp;            //start position for the wall segment
<b class="fc">&nbsp;            int startx = (int) Math.floor(Math.random() * (maxwallwidth - minwallwidth + 1) + minwallwidth);</b>
<b class="fc">&nbsp;            int starty = (int) Math.floor(Math.random() * (maxwallheight - minwallheight + 1) + minwallheight);</b>
&nbsp;
&nbsp;            //how many walls lines we make
&nbsp;            //can be either 1, or 3
&nbsp;            //so a zigzag or straight line
<b class="fc">&nbsp;            int totalwalls = (int) Math.floor(Math.random() * (3 - 1 + 1) + 1);</b>
&nbsp;
&nbsp;
&nbsp;            //if collision ever occurs, we go back to the top while to try again
<b class="fc">&nbsp;            boolean failedgeneration = false;</b>
&nbsp;
<b class="fc">&nbsp;            for (int wallnumber = 1; wallnumber &lt;= totalwalls; wallnumber++) {</b>
&nbsp;
<b class="fc">&nbsp;                int walllenght = (int) Math.floor(Math.random() * (5 - 1 + 1) + 1);</b>
&nbsp;
&nbsp;
&nbsp;                //in order to rotate between vertical and horizontal wall gen
<b class="fc">&nbsp;                if (wallnumber % 2 == 0) {</b>
&nbsp;                    //start vertical 
<b class="fc">&nbsp;                    int north = rand.nextInt(2);  //either 0 or 1, </b>
&nbsp;                    //draw walls 
<b class="fc">&nbsp;                    for (int j = 0; j &lt;= walllenght; j++) {</b>
&nbsp;                        //out of bounds up 
<b class="pc">&nbsp;                        if ((starty + j * (int) (Math.pow(-1, north))) &gt; maxwallheight) {</b>
<b class="nc">&nbsp;                            failedgeneration = true;</b>
<b class="fc">&nbsp;                        } else if ((starty + j * (int) (Math.pow(-1, north))) &lt; minwallheight) {</b>
<b class="fc">&nbsp;                            failedgeneration = true;</b>
&nbsp;                        }
&nbsp;                        //check adjecency trees
<b class="fc">&nbsp;                        else if (foundAdjacentTrees(startx, starty + j * (int) (Math.pow(-1, north)))) {</b>
<b class="fc">&nbsp;                            failedgeneration = true;</b>
&nbsp;                        }
&nbsp;                        //generate tmp tree which we will replace only if full generation succeeds
&nbsp;                        //when if edge cases pass
&nbsp;                        else {
<b class="fc">&nbsp;                            ObjectMap[startx][starty + j * (int) (Math.pow(-1, north))] = Objects.TMP;</b>
&nbsp;                        }
&nbsp;                        //
&nbsp;                        //exist loop
<b class="fc">&nbsp;                        if (failedgeneration) {</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;                    //readjust starty after loop completes
&nbsp;                    //will start drawing from new y position
<b class="fc">&nbsp;                    starty += walllenght * (int) (Math.pow(-1, north));</b>
&nbsp;
&nbsp;                }
&nbsp;                //check if we got any errors in order to restart loop
<b class="fc">&nbsp;                if (failedgeneration) {</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                //case for drawing horizontal lines wall segments
&nbsp;                else {
&nbsp;                    //check if we got any errors in order to restart loop
&nbsp;
&nbsp;                    //used to generate 1 or -1 so that we can raise -1 to power of it
&nbsp;                    //to indicate west or east
<b class="fc">&nbsp;                    int west = rand.nextInt(2);   //from line,  east or west. Walls will be L shapes</b>
<b class="fc">&nbsp;                    for (int j = 0; j &lt;= walllenght; j++) {</b>
&nbsp;                        //out of bounds up 
<b class="pc">&nbsp;                        if (startx + j * (int) (Math.pow(-1, west)) &gt; maxwallwidth) {</b>
<b class="nc">&nbsp;                            failedgeneration = true;</b>
<b class="fc">&nbsp;                        } else if (startx + j * (int) (Math.pow(-1, west)) &lt; minwallwidth) {</b>
<b class="fc">&nbsp;                            failedgeneration = true;</b>
&nbsp;                        }
&nbsp;                        //check adjecency trees
<b class="fc">&nbsp;                        else if (foundAdjacentTrees(startx + j * (int) (Math.pow(-1, west)), starty)) {</b>
<b class="fc">&nbsp;                            failedgeneration = true;</b>
&nbsp;                        }
&nbsp;                        //generate tmp tree which we will replace only if full generation succeeds
&nbsp;                        else {
<b class="fc">&nbsp;                            ObjectMap[startx + j * (int) (Math.pow(-1, west))][starty] = Objects.TMP;</b>
&nbsp;                        }
&nbsp;                        //
&nbsp;
<b class="fc">&nbsp;                        if (failedgeneration) {</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    //start position will now be the x coord
<b class="fc">&nbsp;                    startx += walllenght * (int) (Math.pow(-1, west));</b>
&nbsp;
&nbsp;                }
&nbsp;                //exit loop
<b class="fc">&nbsp;                if (failedgeneration) {</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;            //for successful wall segment generation
<b class="fc">&nbsp;            if (failedgeneration == false) {//in order to exit while loop</b>
&nbsp;
<b class="fc">&nbsp;                createdwall = true;</b>
<b class="fc">&nbsp;                replaceTMPTrees();</b>
&nbsp;            } else {
&nbsp;                //get rid of unusable TMP trees which failed generation
<b class="fc">&nbsp;                removeTMPTrees();</b>
&nbsp;            }
&nbsp;            //this creates a check so that a wall segment doesn&#39;t get stuck endlessly
&nbsp;            //in the while loop
<b class="fc">&nbsp;            attempts++;</b>
<b class="fc">&nbsp;            if (attempts &gt; 100){</b>
<b class="fc">&nbsp;                createdwall = true;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;        }</b>
&nbsp;        //end of while loop
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param dif
&nbsp;     * exact same functionility as {@link #setEnemies(int[],Difficulty)} except for generating REWARD objects
&nbsp;     *
&nbsp;     */
&nbsp;    private void setRegRewards(Difficulty dif) {
<b class="fc">&nbsp;        int rewardCount = 0;</b>
<b class="fc">&nbsp;        ArrayList&lt;int[]&gt; rewardLocations = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="pc">&nbsp;        switch(dif){</b>
<b class="fc">&nbsp;            case EASY: rewardCount = 5;</b>
<b class="fc">&nbsp;                break;</b>
<b class="fc">&nbsp;            case MEDIUM: rewardCount = 10;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case HARD:
<b class="fc">&nbsp;            case INFINITE: rewardCount = 15;</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; rewardCount; i++) {</b>
<b class="fc">&nbsp;            int[] xy = getRandomXY();</b>
<b class="fc">&nbsp;            int x = xy[0];</b>
<b class="fc">&nbsp;            int y = xy[1];</b>
&nbsp;
<b class="fc">&nbsp;            if(ObjectMap[x][y] == Objects.EMPTY){</b>
<b class="fc">&nbsp;                int[] loc = {x,y};</b>
<b class="fc">&nbsp;                boolean valid = checkValidRewardProximity(rewardLocations, loc, dif);</b>
<b class="fc">&nbsp;                if(valid){</b>
<b class="fc">&nbsp;                    ObjectMap[x][y] = Objects.REWARD;</b>
<b class="fc">&nbsp;                    rewardLocations.add(loc);</b>
&nbsp;                }else{
<b class="fc">&nbsp;                    i--;</b>
&nbsp;                }
<b class="fc">&nbsp;            }else{</b>
<b class="fc">&nbsp;                i--;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param rewards
&nbsp;     * @param newReward
&nbsp;     * @param dif
&nbsp;     * @return true if a reward generation is atleast atleast a certain distance
&nbsp;     *         away from the hero position
&nbsp;     *         else return false
&nbsp;     *
&nbsp;     */
&nbsp;    private boolean checkValidRewardProximity(ArrayList&lt;int[]&gt; rewards, int[] newReward, Difficulty dif){
&nbsp;//
&nbsp;
<b class="fc">&nbsp;        int minProximity = 0;</b>
&nbsp;
<b class="fc">&nbsp;        for (int[] reward : rewards) {</b>
<b class="fc">&nbsp;            int x = reward[0];</b>
<b class="fc">&nbsp;            int y = reward[1];</b>
<b class="fc">&nbsp;            int newX = newReward[0];</b>
<b class="fc">&nbsp;            int newY = newReward[1];</b>
&nbsp;
<b class="pc">&nbsp;            switch(dif){</b>
<b class="fc">&nbsp;                case EASY: minProximity = 5;</b>
<b class="fc">&nbsp;                    break;</b>
<b class="fc">&nbsp;                case MEDIUM: minProximity = 3;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case HARD:
<b class="fc">&nbsp;                case INFINITE: minProximity = 0;</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;            //using pythagorean theorem to make sure reward is atleast minProximity away from all other rewards
<b class="fc">&nbsp;            if(Math.sqrt(Math.pow(Math.abs(x-newX),2) + Math.pow(Math.abs(y-newY), 2)) &lt; minProximity){</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param hero
&nbsp;     * @param newEnemy
&nbsp;     * @param dif
&nbsp;     * @return true if an enemy position is too close to a player
&nbsp;     *              else return false
&nbsp;     */
&nbsp;    private boolean checkValidEnemyProximity(int[] hero, int[] newEnemy, Difficulty dif){
&nbsp;
<b class="fc">&nbsp;        int minProximity = 0;</b>
&nbsp;
&nbsp;        //variables holders
<b class="fc">&nbsp;        int x = hero[0];</b>
<b class="fc">&nbsp;        int y = hero[1];</b>
<b class="fc">&nbsp;        int newX = newEnemy[0];</b>
<b class="fc">&nbsp;        int newY = newEnemy[1];</b>
&nbsp;
<b class="pc">&nbsp;        switch(dif){</b>
<b class="fc">&nbsp;            case EASY: minProximity = 10;</b>
<b class="fc">&nbsp;            break;</b>
<b class="fc">&nbsp;            case MEDIUM: minProximity = 7;</b>
<b class="fc">&nbsp;            break;</b>
<b class="fc">&nbsp;            case HARD: case INFINITE: minProximity = 5;</b>
&nbsp;            break;
&nbsp;        }
&nbsp;//            using pythagorean theorem to make sure enemy is atleast minProximity away from hero
<b class="fc">&nbsp;        if(Math.sqrt(Math.pow(Math.abs(x-newX),2) + Math.pow(Math.abs(y-newY), 2)) &lt; minProximity){</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * sets count number of BONUSREWARDS into the ObjectMap at randomly placed positions
&nbsp;     * @param count the number of BONUS objects to be randomly generated
&nbsp;     *
&nbsp;     *
&nbsp;     */
&nbsp;    public void generateBonusrewards(int count){
&nbsp;        //how many rewards
<b class="fc">&nbsp;        for (int BonusCnt = 1; BonusCnt &lt;= count; BonusCnt++){</b>
&nbsp;            //need to stay in while loop while randomXY finds a position
&nbsp;            //that has an empty tile
<b class="fc">&nbsp;            boolean posfound = false;</b>
<b class="fc">&nbsp;            while(!posfound){</b>
&nbsp;                //generate an array {x,y} where both variables are within bounds of map
<b class="fc">&nbsp;                int[] coords = getRandomXY();</b>
&nbsp;                //check to see if generation is a valid
<b class="fc">&nbsp;                if (ObjectMap[coords[0]][coords[1]] == Objects.EMPTY){</b>
&nbsp;
<b class="fc">&nbsp;                    ObjectMap[coords[0]][coords[1]] = Objects.BONUS;</b>
<b class="fc">&nbsp;                    posfound = true;</b>
&nbsp;                }
&nbsp;                //else case means we need a new XY so we go back to while loop
&nbsp;                //and get another randomXY
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * based on the difficulty, calls helper function {@link #generateBonusrewards(int)} method. See definition
&nbsp;     * @param dif Difficulty of the game
&nbsp;     *
&nbsp;     */
&nbsp;    private void setBonusRewards(Difficulty dif) {
<b class="pc">&nbsp;        switch (dif){</b>
&nbsp;            case EASY:
<b class="fc">&nbsp;                generateBonusrewards(3);</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case MEDIUM:
<b class="fc">&nbsp;                generateBonusrewards(2);</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case HARD:
&nbsp;            case INFINITE:
<b class="fc">&nbsp;                generateBonusrewards(1);</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * based on the difficulty, calls helper function {@link #generateBonusrewards(int)} method. See definition
&nbsp;     * @param heroLoc heroes locations. See {@link #setHeroLocation()}
&nbsp;     * @param dif game difficulty
&nbsp;     *
&nbsp;     *
&nbsp;     */
&nbsp;    private void setEnemies(int[] heroLoc, Difficulty dif) {
&nbsp;        //initialize variable to hold
<b class="fc">&nbsp;        int enemyCount = 0;</b>
<b class="pc">&nbsp;        switch(dif){</b>
&nbsp;            case EASY:
<b class="fc">&nbsp;                enemyCount = 1;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case MEDIUM:
<b class="fc">&nbsp;                enemyCount = 2;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case HARD:
&nbsp;            case INFINITE:
<b class="fc">&nbsp;                enemyCount = 3;</b>
&nbsp;                break;
&nbsp;        }
&nbsp;        //loop for the number of enemies
<b class="fc">&nbsp;        for(int i = 0; i &lt; enemyCount; i++){</b>
<b class="fc">&nbsp;            int[] xy = getRandomXY();</b>
<b class="fc">&nbsp;            int x = xy[0];</b>
<b class="fc">&nbsp;            int y = xy[1];</b>
&nbsp;            //must pass
&nbsp;            //1)checkValidEnemy Proximity
&nbsp;            //2)be on empty tile
&nbsp;            //3)tile below cannot be a tree (creates bug when generating bear initially
<b class="fc">&nbsp;            if(!checkValidEnemyProximity(heroLoc, xy, dif) || ObjectMap[x][y] != Objects.EMPTY || ObjectMap[x][y+1] == Objects.TREE){</b>
&nbsp;                //the loop did create a succesful generation so decrement by one
<b class="fc">&nbsp;                i--;</b>
&nbsp;            }else{
&nbsp;                //checkValidEnemyProximity return true
<b class="fc">&nbsp;                ObjectMap[x][y] = Objects.ENEMY;</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generate 5 randomly located BUSH objects on ObjectMap
&nbsp;     */
&nbsp;    private void setBushes() {
<b class="fc">&nbsp;        int bushCount = 5;</b>
<b class="fc">&nbsp;        for(int i = 0; i &lt; bushCount; i++){</b>
&nbsp;            //get random xy coordinate
<b class="fc">&nbsp;            int[] xy = getRandomXY();</b>
<b class="fc">&nbsp;            int x = xy[0];</b>
<b class="fc">&nbsp;            int y = xy[1];</b>
&nbsp;            //must be an empty tile
<b class="fc">&nbsp;            if(ObjectMap[x][y] == Objects.EMPTY) {</b>
<b class="fc">&nbsp;                ObjectMap[x][y] = Objects.BUSH;</b>
&nbsp;            }else{
&nbsp;                //generation did not succesful place a bush
&nbsp;                //so decrement i for one more iteration of loop
<b class="fc">&nbsp;                i--;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generate count number of randomly placed traps on ObjectMap
&nbsp;     * @param count number of traps
&nbsp;     *
&nbsp;     */
&nbsp;    public void generateTraps(int count){
&nbsp;
<b class="fc">&nbsp;        for (int trapcount = 1; trapcount &lt;= count; trapcount++){</b>
<b class="fc">&nbsp;            boolean posfound = false;</b>
<b class="fc">&nbsp;            while(!posfound){</b>
<b class="fc">&nbsp;                int[] coords = getRandomXY();</b>
&nbsp;                //check to see if generation is a valid
<b class="fc">&nbsp;                if (ObjectMap[coords[0]][coords[1]] == Objects.EMPTY){</b>
&nbsp;
<b class="fc">&nbsp;                    ObjectMap[coords[0]][coords[1]] = Objects.TRAP;</b>
<b class="fc">&nbsp;                    posfound = true;</b>
&nbsp;                }
&nbsp;                //else case means we need a new XY so we go back to while loop
&nbsp;                //and get another randomXY
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param dif based on the difficulty, call {@link #generateTraps(int)} method()
&nbsp;     *            with a different number of traps to generate
&nbsp;     *
&nbsp;     */
&nbsp;    private void setTraps(Difficulty dif) {
&nbsp;        //does not matter if traps are in close to eachother
&nbsp;        //so we don&#39;t check for proximity when generating
<b class="pc">&nbsp;        switch(dif){</b>
&nbsp;            case EASY:
<b class="fc">&nbsp;                generateTraps(4);</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case MEDIUM:
<b class="fc">&nbsp;                generateTraps(7);</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case HARD:
<b class="fc">&nbsp;                generateTraps(11);</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case INFINITE:
<b class="fc">&nbsp;                generateTraps(11);</b>
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private int[] setHeroLocation() {
&nbsp;
&nbsp;        //FIXED
&nbsp;        /*
&nbsp;        boolean heroNotSpawned = true;
&nbsp;
&nbsp;        while(heroNotSpawned){
&nbsp;            int[] xy = getRandomXY();
&nbsp;            int x = xy[0];
&nbsp;            int y = xy[1];
&nbsp;            if(ObjectMap[x][y] == Objects.EMPTY) {
&nbsp;                ObjectMap[x][y] = Objects.HERO;
&nbsp;                heroNotSpawned = false;
&nbsp;                int heroLoc[] = {x,y};
&nbsp;                return heroLoc;
&nbsp;            }
&nbsp;        }
&nbsp;        //case will never hit
&nbsp;        return null;
&nbsp;
&nbsp;         */
<b class="fc">&nbsp;        Random rand = new Random(); //instance of random class</b>
&nbsp;
&nbsp;        // Hero at south wall, so door appears west,north,east wall
&nbsp;        //Somewhere on the south wall
<b class="fc">&nbsp;        int x = rand.nextInt(columns-2)+1;</b>
<b class="fc">&nbsp;        int y = rows-1;</b>
&nbsp;
<b class="fc">&nbsp;        ObjectMap[x][y] = Objects.HERO;</b>
<b class="fc">&nbsp;        int heroLoc[] = {x,y};</b>
<b class="fc">&nbsp;        return heroLoc;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Randomly generate the door on the perimeter of the map for the player to exit
&nbsp;     *
&nbsp;     */
&nbsp;    public void setDoor() {
<b class="fc">&nbsp;        Random rand = new Random(); //instance of random class</b>
&nbsp;
&nbsp;        //0 = north, 1 = east, 2 = south, 3 = west;
&nbsp;        //generate number between 0 and 3
<b class="fc">&nbsp;        int side = rand.nextInt(2);</b>
<b class="fc">&nbsp;        int x = 0;</b>
<b class="fc">&nbsp;        int y = 0;</b>
&nbsp;
<b class="pc">&nbsp;        switch(side){</b>
&nbsp;            // Hero at south wall, so door appears west,north,east wall
&nbsp;            /*
&nbsp;            case(0):
&nbsp;                 //Somewhere on the south wall
&nbsp;                 x = rand.nextInt(columns-2)+1;
&nbsp;                 y = rows-1;
&nbsp;                break;
&nbsp;
&nbsp;             */
&nbsp;            case(0):
&nbsp;                //Somewhere on the WEST wall
<b class="fc">&nbsp;                y = rand.nextInt(rows-2)+1;</b>
<b class="fc">&nbsp;                x = columns-1;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case(1):
&nbsp;                //North wall
<b class="fc">&nbsp;                x = rand.nextInt(columns-2)+1;</b>
<b class="fc">&nbsp;                y = 0;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case(2):
&nbsp;                //EAST wall
<b class="nc">&nbsp;                y = rand.nextInt(rows-2)+1 ;</b>
<b class="nc">&nbsp;                x = 0;</b>
&nbsp;                break;
&nbsp;        }
<b class="fc">&nbsp;        ObjectMap[x][y] = Objects.EXIT;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param dif
&nbsp;     * Generates a new, unique, random map
&nbsp;     * based on the difficulty argument provided.
&nbsp;     * see following function descriptions for the methods used in this method
&nbsp;     * {@link #setEmptyTiles()}
&nbsp;     * {@link #setOuterWalls()}
&nbsp;     * {@link #setInnerWalls(Difficulty)}
&nbsp;     * {@link #setBonusRewards(Difficulty)}
&nbsp;     * {@link #setBonusRewards(Difficulty)}
&nbsp;     * {@link #setRegRewards(Difficulty)}
&nbsp;     * {@link #setTraps(Difficulty)}
&nbsp;     * {@link #setEnemies(int[], Difficulty)}
&nbsp;     * {@link #setDoor()}
&nbsp;     * {@link #setBushes()}
&nbsp;     */
&nbsp;    public void initialiseBoard(Difficulty dif) {
&nbsp;
&nbsp;        int heroLoc[];
&nbsp;
&nbsp;        //empty tiles to show to which positions will be available
<b class="fc">&nbsp;        setEmptyTiles();</b>
&nbsp;        //walls
<b class="fc">&nbsp;        setOuterWalls();</b>
<b class="fc">&nbsp;        setInnerWalls(dif);</b>
&nbsp;
&nbsp;        //static entities generations
<b class="fc">&nbsp;        setBonusRewards(dif);</b>
<b class="fc">&nbsp;        setRegRewards(dif);</b>
<b class="fc">&nbsp;        setTraps(dif);</b>
&nbsp;
&nbsp;        //moving entities
<b class="fc">&nbsp;        heroLoc = setHeroLocation();</b>
<b class="fc">&nbsp;        setEnemies(heroLoc, dif);</b>
&nbsp;
&nbsp;        //miscelanous generation
<b class="fc">&nbsp;        setDoor();</b>
<b class="fc">&nbsp;        setBushes();</b>
&nbsp;    }
&nbsp;
&nbsp;    //following will be used in game logic
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param x
&nbsp;     * @param y
&nbsp;     * @return ObjectMap[x][y]
&nbsp;     * compatible with seperate x and y coordinates
&nbsp;     */
&nbsp;    public Objects getTypeAt(int x, int y) {
<b class="fc">&nbsp;        return ObjectMap[x][y];</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param pos
&nbsp;     * @return ObjectMap[pos.getX()][pos.getY()]
&nbsp;     * compatible with Position class parameter
&nbsp;     * see {@link Position#getX()}  and  {@link Position#getY()}
&nbsp;     */
&nbsp;    public Objects getTypeAt(Position pos) {
<b class="fc">&nbsp;        return ObjectMap[pos.getX()][pos.getY()];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param pos
&nbsp;     * @param type
&nbsp;     * set index at pos.getX() and pos.getY() to type
&nbsp;     * see {@link Position#getX()}  and  {@link Position#getY()}
&nbsp;     */
&nbsp;    public void setTypeAt(Position pos, Objects type) {
<b class="fc">&nbsp;        ObjectMap[pos.getX()][pos.getY()] = type;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @param x
&nbsp;     * @param y
&nbsp;     * @param data
&nbsp;     * compatible with x and y coordinates, see {@link #setTypeAt(Position, Objects)}
&nbsp;     */
&nbsp;    public void updateBoard(int x, int y, Objects data) {
<b class="nc">&nbsp;        ObjectMap[x][y] = data;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @return how many rows
&nbsp;     */
&nbsp;    public int getboardheight() {
<b class="fc">&nbsp;        return rows;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @return how many columns
&nbsp;     */
&nbsp;    public int getboardwidth() {
<b class="fc">&nbsp;        return columns;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @return an array of ints where array[0] = x
&nbsp;     */
&nbsp;    private int[] getRandomXY() {
&nbsp;
<b class="fc">&nbsp;        Random rand = new Random(); //instance of random class</b>
&nbsp;
&nbsp;        //-2 + 1 in order to not consider the border
<b class="fc">&nbsp;        int x = rand.nextInt(columns-2) + 1;</b>
<b class="fc">&nbsp;        int y = rand.nextInt(rows-2) + 1;</b>
&nbsp;        //store inside of array
<b class="fc">&nbsp;        int[] xy = {x,y};</b>
&nbsp;
<b class="fc">&nbsp;        return xy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @return ObjectMap variable
&nbsp;     */
&nbsp;    public Objects[][] getBoardData(){
<b class="fc">&nbsp;        return ObjectMap;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;}
&nbsp;
&nbsp;    /* might be redunant
&nbsp;    public String[][] getBoardData(){
&nbsp;        return string2DArray;
&nbsp;    }
&nbsp;    */
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-11-26 23:48</div>
</div>
</body>
</html>
